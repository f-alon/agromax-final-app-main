// AGROMEX - Motor con Autoinstalación de Base de Datos
// Versión 4.4 - Implementadas Rutas de Registro y Login de Usuarios

const express = require('express');
const { Pool } = require('pg');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware para parsear JSON
app.use(express.json());

// --- CONFIGURACIÓN DE LA BASE DE DATOS ---
// Se asume que DATABASE_URL y JWT_SECRET están configuradas como variables de entorno
const connectionString = process.env.DATABASE_URL;
const jwtSecret = process.env.JWT_SECRET || 'secreto-de-desarrollo-muy-seguro'; // Usar un secreto fuerte en producción

const pool = new Pool({
  connectionString: connectionString,
  ssl: {
    rejectUnauthorized: false
  }
});

// --- SCRIPT DE CREACIÓN DE LA BASE DE DATOS ---
const setupQuery = `
  -- ========= SECCIÓN 0: LIMPIEZA PREVIA (TABLA POR TABLA) =========
  DROP TABLE IF EXISTS fotos_vacas CASCADE;
  DROP TABLE IF EXISTS registros_reproduccion CASCADE;
  DROP TABLE IF EXISTS registros_salud CASCADE;
  DROP TABLE IF EXISTS registros_produccion CASCADE;
  DROP TABLE IF EXISTS historial_movimientos CASCADE;
  DROP TABLE IF EXISTS vacas CASCADE;
  DROP TABLE IF EXISTS rodeos CASCADE;
  DROP TABLE IF EXISTS usuario_establecimiento_roles CASCADE;
  DROP TABLE IF EXISTS establecimientos CASCADE;
  DROP TABLE IF EXISTS usuarios CASCADE;

  -- ========= SECCIÓN 1: AUTENTICACIÓN Y GESTIÓN DE ESTABLECIMIENTOS =========
  CREATE TABLE usuarios (
      id SERIAL PRIMARY KEY,
      email VARCHAR(255) UNIQUE NOT NULL,
      password_hash VARCHAR(255) NOT NULL,
      nombre_completo VARCHAR(150),
      fecha_creacion TIMESTAMPTZ DEFAULT NOW()
  );

  CREATE TABLE establecimientos (
      id SERIAL PRIMARY KEY,
      nombre VARCHAR(150) NOT NULL,
      numero_oficial VARCHAR(50),
      propietario_id INTEGER NOT NULL REFERENCES usuarios(id),
      fecha_creacion TIMESTAMPTZ DEFAULT NOW()
  );

  CREATE TABLE usuario_establecimiento_roles (
      usuario_id INTEGER NOT NULL REFERENCES usuarios(id) ON DELETE CASCADE,
      establecimiento_id INTEGER NOT NULL REFERENCES establecimientos(id) ON DELETE CASCADE,
      rol VARCHAR(50) NOT NULL,
      PRIMARY KEY (usuario_id, establecimiento_id)
  );

  -- ========= SECCIÓN 2: DATOS ESPECÍFICOS DEL ESTABLECIMIENTO =========
  CREATE TABLE rodeos (
      id SERIAL PRIMARY KEY,
      establecimiento_id INTEGER NOT NULL REFERENCES establecimientos(id) ON DELETE CASCADE,
      nombre VARCHAR(100) NOT NULL,
      descripcion TEXT,
      fecha_creacion TIMESTAMPTZ DEFAULT NOW()
  );

  CREATE TABLE vacas (
      id SERIAL PRIMARY KEY,
      establecimiento_id INTEGER NOT NULL REFERENCES establecimientos(id) ON DELETE CASCADE,
      caravana_senasa VARCHAR(50),
      caravana_interna VARCHAR(50),
      nombre VARCHAR(100),
      raza VARCHAR(50),
      fecha_nacimiento DATE,
      estado_actual VARCHAR(50),
      estado_reproductivo VARCHAR(50),
      rodeo_id INTEGER REFERENCES rodeos(id),
      madre_id INTEGER REFERENCES vacas(id),
      padre_nombre VARCHAR(100),
      fecha_ingreso DATE DEFAULT CURRENT_DATE,
      activa BOOLEAN DEFAULT TRUE,
      UNIQUE (establecimiento_id, caravana_senasa),
      UNIQUE (establecimiento_id, caravana_interna)
  );

  CREATE TABLE historial_movimientos (
      id SERIAL PRIMARY KEY,
      establecimiento_id INTEGER NOT NULL REFERENCES establecimientos(id) ON DELETE CASCADE,
      vaca_id INTEGER NOT NULL REFERENCES vacas(id) ON DELETE CASCADE,
      rodeo_origen_id INTEGER REFERENCES rodeos(id),
      rodeo_destino_id INTEGER NOT NULL REFERENCES rodeos(id),
      fecha_movimiento TIMESTAMPTZ DEFAULT NOW(),
      motivo TEXT
  );
  
  CREATE TABLE registros_produccion (
    id SERIAL PRIMARY KEY,
    vaca_id INTEGER NOT NULL REFERENCES vacas(id) ON DELETE CASCADE,
    establecimiento_id INTEGER NOT NULL REFERENCES establecimientos(id) ON DELETE CASCADE,
    fecha_registro DATE NOT NULL,
    litros_dia DECIMAL(5, 2) NOT NULL,
    calidad_grasa DECIMAL(4, 2),
    calidad_proteina DECIMAL(4, 2),
    UNIQUE (vaca_id, fecha_registro)
  );

  CREATE TABLE registros_salud (
      id SERIAL PRIMARY KEY,
      vaca_id INTEGER NOT NULL REFERENCES vacas(id) ON DELETE CASCADE,
      establecimiento_id INTEGER NOT NULL REFERENCES establecimientos(id) ON DELETE CASCADE,
      fecha_evento DATE NOT NULL,
      tipo_evento VARCHAR(50) NOT NULL,
      descripcion TEXT NOT NULL,
      costo DECIMAL(10, 2),
      observaciones TEXT
  );

  CREATE TABLE registros_reproduccion (
      id SERIAL PRIMARY KEY,
      vaca_id INTEGER NOT NULL REFERENCES vacas(id) ON DELETE CASCADE,
      establecimiento_id INTEGER NOT NULL REFERENCES establecimientos(id) ON DELETE CASCADE,
      fecha_evento DATE NOT NULL,
      fecha_es_aproximada BOOLEAN DEFAULT FALSE,
      tipo_evento VARCHAR(50) NOT NULL,
      detalle TEXT,
      inseminador VARCHAR(100),
      cría_id_oficial VARCHAR(50)
  );

  CREATE TABLE fotos_vacas (
      id SERIAL PRIMARY KEY,
      vaca_id INTEGER NOT NULL REFERENCES vacas(id) ON DELETE CASCADE,
      establecimiento_id INTEGER NOT NULL REFERENCES establecimientos(id) ON DELETE CASCADE,
      url_foto VARCHAR(255) NOT NULL,
      descripcion TEXT,
      fecha_subida TIMESTAMPTZ DEFAULT NOW()
  );

  -- ========= SECCIÓN 3: ÍNDICES PARA MEJORAR EL RENDIMIENTO =========
  CREATE INDEX idx_vacas_establecimiento ON vacas(establecimiento_id);
  CREATE INDEX idx_rodeos_establecimiento ON rodeos(establecimiento_id);
  CREATE INDEX idx_movimientos_vaca ON historial_movimientos(vaca_id);
  CREATE INDEX idx_produccion_vaca ON registros_produccion(vaca_id);
  CREATE INDEX idx_salud_vaca ON registros_salud(vaca_id);
  CREATE INDEX idx_reproduccion_vaca ON registros_reproduccion(vaca_id);
  CREATE INDEX idx_fotos_vaca ON fotos_vacas(vaca_id);
`;

// --- MIDDLEWARE DE AUTENTICACIÓN (EL "GUARDIA DE SEGURIDAD") ---
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1]; 
  if (token == null) return res.status(401).json({ message: 'No se proporcionó token de acceso.' });

  jwt.verify(token, jwtSecret, (err, user) => {
    if (err) return res.status(403).json({ message: 'Token no válido o expirado.' });
    req.user = user;
    next();
  });
};

// --- MIDDLEWARE DE AUTORIZACIÓN (VERIFICADOR DE PERMISOS DE ESTABLECIMIENTO) ---
const authorizeEstablecimiento = async (req, res, next) => {
    const establecimientoId = req.params.establecimientoId;
    const userId = req.user.userId;
    try {
        const checkAccessQuery = `SELECT * FROM usuario_establecimiento_roles WHERE usuario_id = $1 AND establecimiento_id = $2;`;
        const result = await pool.query(checkAccessQuery, [userId, establecimientoId]);
        if (result.rows.length === 0) {
            return res.status(403).json({ message: 'Acceso denegado a este establecimiento.' });
        }
        next();
    } catch (error) {
        console.error('Error en la autorización de establecimiento:', error);
        res.status(500).json({ message: 'Error interno del servidor.' });
    }
};

// --- NUEVO: MIDDLEWARE DE AUTORIZACIÓN PARA SUPERADMINISTRADOR ---
const authorizeAdmin = async (req, res, next) => {
    const userId = req.user.userId;
    try {
        const userQuery = 'SELECT email FROM usuarios WHERE id = $1';
        const result = await pool.query(userQuery, [userId]);
        if (result.rows.length === 0) {
            return res.status(404).json({ message: 'Usuario no encontrado.' });
        }
        const userEmail = result.rows[0].email;
        // Por ahora, el superadministrador se identifica por su email.
        // A futuro, esto podría cambiarse por un campo de "rol" en la tabla de usuarios.
        if (userEmail !== 'admin@agromex.com') {
            return res.status(403).json({ message: 'Acceso denegado. Se requieren privilegios de administrador.' });
        }
        next();
    } catch (error) {
        console.error('Error en la autorización de administrador:', error);
        res.status(500).json({ message: 'Error interno del servidor.' });
    }
};


async function startServer() {
  let client;
  try {
    console.log('Conectando a la base de datos...');
    client = await pool.connect();
    console.log('Conexión exitosa. Verificando si las tablas existen...');
    const checkTable = await client.query("SELECT to_regclass('public.usuarios');");
    if (checkTable.rows[0].to_regclass === null) {
      console.log('Las tablas no existen. Creando la estructura de la base de datos...');
      await client.query(setupQuery);
      console.log('¡Base de datos creada y configurada exitosamente!');
    } else {
      console.log('La base de datos ya está configurada. Saltando la creación de tablas.');
    }
  } catch (err) {
    console.error('Error durante la configuración inicial de la base de datos:', err.stack);
  } finally {
    if (client) client.release();
  }

  // --- RUTAS DE LA API ---
  app.get('/', (req, res) => res.send('¡El motor de AGROMEX está en marcha y conectado a la base de datos!'));

  // --- Rutas de Autenticación (públicas) ---
  app.post('/api/auth/register', async (req, res) => {
    const { email, password, nombre_completo } = req.body;

    // Validación simple
    if (!email || !password || !nombre_completo) {
        return res.status(400).json({ message: 'Todos los campos son requeridos: email, password, nombre_completo.' });
    }

    try {
        // Hashear la contraseña
        const salt = await bcrypt.genSalt(10);
        const password_hash = await bcrypt.hash(password, salt);

        // Insertar usuario en la base de datos
        const newUserQuery = `
            INSERT INTO usuarios (email, password_hash, nombre_completo)
            VALUES ($1, $2, $3)
            RETURNING id, email, nombre_completo, fecha_creacion;
        `;
        const result = await pool.query(newUserQuery, [email, password_hash, nombre_completo]);
        
        res.status(201).json({
            message: 'Usuario registrado exitosamente.',
            user: result.rows[0]
        });

    } catch (error) {
        // Manejar error de email duplicado (código de error 23505 para unique_violation en PostgreSQL)
        if (error.code === '23505') {
            return res.status(409).json({ message: 'El email ya está registrado.' });
        }
        console.error('Error en el registro de usuario:', error);
        res.status(500).json({ message: 'Error interno del servidor.' });
    }
  });

  app.post('/api/auth/login', async (req, res) => {
    const { email, password } = req.body;

    if (!email || !password) {
        return res.status(400).json({ message: 'Email y password son requeridos.' });
    }

    try {
        // Buscar al usuario por email
        const userQuery = 'SELECT * FROM usuarios WHERE email = $1';
        const result = await pool.query(userQuery, [email]);

        if (result.rows.length === 0) {
            return res.status(401).json({ message: 'Credenciales inválidas.' }); // Mensaje genérico por seguridad
        }

        const user = result.rows[0];

        // Comparar la contraseña
        const isMatch = await bcrypt.compare(password, user.password_hash);
        if (!isMatch) {
            return res.status(401).json({ message: 'Credenciales inválidas.' });
        }

        // Crear el token JWT
        const payload = {
            userId: user.id,
            email: user.email
        };

        const token = jwt.sign(payload, jwtSecret, { expiresIn: '1d' }); // El token expira en 1 día

        res.status(200).json({
            message: 'Inicio de sesión exitoso.',
            token: token,
            user: {
                id: user.id,
                email: user.email,
                nombre_completo: user.nombre_completo
            }
        });

    } catch (error) {
        console.error('Error en el inicio de sesión:', error);
        res.status(500).json({ message: 'Error interno del servidor.' });
    }
  });

  // --- Rutas de Establecimientos (protegidas) ---
  app.post('/api/establecimientos', authenticateToken, async (req, res) => { /* ...código a implementar... */ });

  // --- Rutas de Gestión de Rodeos ---
  app.post('/api/establecimientos/:establecimientoId/rodeos', authenticateToken, authorizeEstablecimiento, async (req, res) => { /* ...código a implementar... */ });
  app.get('/api/establecimientos/:establecimientoId/rodeos', authenticateToken, authorizeEstablecimiento, async (req, res) => { /* ...código a implementar... */ });
  
  // --- Rutas de Gestión de Vacas ---
  app.post('/api/establecimientos/:establecimientoId/vacas', authenticateToken, authorizeEstablecimiento, async (req, res) => { /* ...código a implementar... */ });
  app.get('/api/establecimientos/:establecimientoId/vacas', authenticateToken, authorizeEstablecimiento, async (req, res) => { /* ...código a implementar... */ });
  app.get('/api/establecimientos/:establecimientoId/vacas/:vacaId', authenticateToken, authorizeEstablecimiento, async (req, res) => { /* ...código a implementar... */ });
  app.put('/api/establecimientos/:establecimientoId/vacas/:vacaId', authenticateToken, authorizeEstablecimiento, async (req, res) => { /* ...código a implementar... */ });
  app.delete('/api/establecimientos/:establecimientoId/vacas/:vacaId', authenticateToken, authorizeEstablecimiento, async (req, res) => { /* ...código a implementar... */ });

  // --- Rutas de Historiales ---
  app.post('/api/establecimientos/:establecimientoId/vacas/:vacaId/salud', authenticateToken, authorizeEstablecimiento, async (req, res) => { /* ...código a implementar... */ });
  app.get('/api/establecimientos/:establecimientoId/vacas/:vacaId/salud', authenticateToken, authorizeEstablecimiento, async (req, res) => { /* ...código a implementar... */ });
  app.post('/api/establecimientos/:establecimientoId/vacas/:vacaId/reproduccion', authenticateToken, authorizeEstablecimiento, async (req, res) => { /* ...código a implementar... */ });
  app.get('/api/establecimientos/:establecimientoId/vacas/:vacaId/reproduccion', authenticateToken, authorizeEstablecimiento, async (req, res) => { /* ...código a implementar... */ });
  app.post('/api/establecimientos/:establecimientoId/vacas/:vacaId/produccion', authenticateToken, authorizeEstablecimiento, async (req, res) => { /* ...código a implementar... */ });
  app.get('/api/establecimientos/:establecimientoId/vacas/:vacaId/produccion', authenticateToken, authorizeEstablecimiento, async (req, res) => { /* ...código a implementar... */ });
  app.post('/api/establecimientos/:establecimientoId/vacas/:vacaId/fotos', authenticateToken, authorizeEstablecimiento, async (req, res) => { /* ...código a implementar... */ });
  app.get('/api/establecimientos/:establecimientoId/vacas/:vacaId/fotos', authenticateToken, authorizeEstablecimiento, async (req, res) => { /* ...código a implementar... */ });

  // --- Ruta de Alertas ---
  app.get('/api/establecimientos/:establecimientoId/alertas', authenticateToken, authorizeEstablecimiento, async (req, res) => { /* ...código a implementar... */ });

  // --- NUEVA RUTA DE ADMINISTRACIÓN ---
  // Obtener todos los establecimientos (solo para el Superadministrador)
  app.get('/api/admin/establecimientos', authenticateToken, authorizeAdmin, async (req, res) => {
    try {
        const getEstablecimientosQuery = `
            SELECT e.id, e.nombre, e.numero_oficial, u.email as propietario_email 
            FROM establecimientos e
            JOIN usuarios u ON e.propietario_id = u.id
            ORDER BY e.id ASC;
        `;
        const result = await pool.query(getEstablecimientosQuery);
        res.status(200).json(result.rows);
    } catch (error) {
        console.error('Error al obtener los establecimientos:', error);
        res.status(500).json({ message: 'Error interno del servidor.' });
    }
  });

  // Encendemos el servidor.
  app.listen(PORT, () => {
    console.log(`Servidor escuchando en el puerto ${PORT}`);
  });
}

startServer();
